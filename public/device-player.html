<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Device Player - Digital Signage</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.2/font/bootstrap-icons.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #0a0a0a;
            overflow-x: hidden;
            overflow-y: auto;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }
        
        /* Main Container */
        #mainContainer {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* Video Player Container */
        #videoContainer {
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 20px;
            height: 70vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #videoPlayer {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: contain;
        }
        
        /* When in fullscreen, make video fill screen */
        #videoPlayer:fullscreen {
            max-height: 100vh;
            object-fit: contain;
        }
        
        #videoPlayer:-webkit-full-screen {
            max-height: 100vh;
            object-fit: contain;
        }
        
        #videoPlayer:-moz-full-screen {
            max-height: 100vh;
            object-fit: contain;
        }
        
        /* Cache Progress Indicator */
        #cacheIndicator {
            background: #10b981;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 13px;
            margin-bottom: 15px;
            opacity: 0;
            transition: opacity 0.3s;
            display: none;
        }
        
        #cacheIndicator.show {
            opacity: 1;
            display: block;
        }
        
        #cacheIndicator .progress-bar {
            height: 6px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            margin-top: 8px;
            overflow: hidden;
        }
        
        #cacheIndicator .progress-fill {
            height: 100%;
            background: white;
            width: 0%;
            transition: width 0.3s;
        }
        
        /* Controls Section */
        #controlsSection {
            background: #1a1a1a;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        /* Deregister Button */
        #deregisterBtn {
            background: #dc2626;
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 8px;
            font-size: 15px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s, transform 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            width: 100%;
            justify-content: center;
        }
        
        #deregisterBtn:hover {
            background: #b91c1c;
            transform: translateY(-2px);
        }
        
        #deregisterBtn:active {
            transform: translateY(0);
        }
        
        /* Debug Info Section */
        #debugSection {
            background: #1a1a1a;
            border-radius: 12px;
            padding: 20px;
            color: #9ca3af;
            font-size: 14px;
            font-family: monospace;
        }
        
        #debugSection h3 {
            color: #fff;
            margin: 0 0 15px 0;
            font-size: 16px;
        }
        
        #debugSection p {
            margin: 8px 0;
            color: #d1d5db;
        }
        
        #debugSection strong {
            color: #10b981;
            display: inline-block;
            min-width: 150px;
        }
        
        
        /* Click to Play Overlay (only shows if autoplay blocked) */
        #clickToPlayOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            color: white;
            cursor: pointer;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        
        #clickToPlayOverlay.show {
            opacity: 1;
            visibility: visible;
        }
        
        #clickToPlayOverlay i {
            font-size: 80px;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        #clickToPlayOverlay p {
            font-size: 24px;
            margin: 0;
        }
        
        /* Error Display */
        #errorOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        
        #errorOverlay.show {
            opacity: 1;
            visibility: visible;
        }
        
        .error-container {
            background: #dc2626;
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 500px;
        }
        
        .error-container h2 {
            margin-bottom: 15px;
        }
        
        .error-container button {
            margin-top: 15px;
            padding: 10px 30px;
            background: white;
            color: #dc2626;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="mainContainer">
        <!-- Video Player -->
        <div id="videoContainer">
            <video id="videoPlayer" controls autoplay playsinline></video>
        </div>
        
        <!-- Controls Section -->
        <div id="controlsSection">
            <!-- Cache Progress Indicator -->
            <div id="cacheIndicator">
                <div id="cacheText">Caching videos... 0/0</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="cacheProgressBar"></div>
                </div>
            </div>
            
            <!-- Deregister Button -->
            <button id="deregisterBtn" onclick="goHome()">
                <i class="bi bi-arrow-left-circle"></i>
                Change Playlist / Deregister Device
            </button>
        </div>
        
        <!-- Debug Info Section -->
        <div id="debugSection">
            <h3>üìä Playback Information</h3>
            <p><strong>Device UID:</strong> <span id="infoDeviceUID">-</span></p>
            <p><strong>Playlist:</strong> <span id="infoPlaylistName">-</span></p>
            <p><strong>Current Video:</strong> <span id="infoCurrentVideo">-</span> / <span id="infoTotalVideos">-</span></p>
            <p><strong>Timeline Loop:</strong> #<span id="infoLoopCount">0</span></p>
            <p><strong>Video Time:</strong> <span id="infoVideoTime">00:00</span> / <span id="infoVideoDuration">00:00</span></p>
            <p><strong>Item Duration:</strong> <span id="infoItemDuration">-</span>s</p>
            <p><strong>Item Elapsed:</strong> <span id="infoItemElapsed">0</span>s</p>
            <p><strong>Cache Status:</strong> <span id="infoCacheStatus">-</span></p>
            <p><strong>Next Timeline Check:</strong> <span id="infoNextUpdate">-</span>s</p>
        </div>
    </div>
    
    <!-- Click to Play Overlay -->
    <div id="clickToPlayOverlay" onclick="handleClickToPlay()">
        <i class="bi bi-play-circle-fill"></i>
        <p>Click to Play with Sound</p>
    </div>
    
    <!-- Error Overlay -->
    <div id="errorOverlay">
        <div class="error-container">
            <h2>‚ö†Ô∏è Error</h2>
            <p id="errorMessage">An error occurred</p>
            <button onclick="goHome()">Go Home</button>
        </div>
    </div>

    <script>
        // ==================== INDEXEDDB SETUP ====================
        const DB_NAME = 'digitalSignageCache';
        const DB_VERSION = 1;
        const VIDEO_STORE = 'videos';
        let db = null;

        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(VIDEO_STORE)) {
                        db.createObjectStore(VIDEO_STORE, { keyPath: 'id' });
                    }
                };
            });
        }

        async function saveVideoToCache(videoId, videoBlob) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([VIDEO_STORE], 'readwrite');
                const store = transaction.objectStore(VIDEO_STORE);
                const request = store.put({ id: videoId, blob: videoBlob, cachedAt: Date.now() });
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        async function getVideoFromCache(videoId) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([VIDEO_STORE], 'readonly');
                const store = transaction.objectStore(VIDEO_STORE);
                const request = store.get(videoId);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function clearVideoCache() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([VIDEO_STORE], 'readwrite');
                const store = transaction.objectStore(VIDEO_STORE);
                const request = store.clear();
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // ==================== GLOBAL STATE ====================
        let registrationData = null;
        let timelineItems = [];
        let currentVideoIndex = 0;
        let loopCount = 0;
        let videoPlayer = null;
        let cacheStatus = {};
        let itemStartTime = 0;
        let itemDuration = 0;
        let checkIntervalId = null;
        let updateIntervalId = null;
        let timelineCheckIntervalId = null;
        let lastTimelineCheck = Date.now();
        let hasEnteredFullscreenOnce = false;

        // ==================== INITIALIZATION ====================
        document.addEventListener('DOMContentLoaded', init);

        async function init() {
            console.log('üöÄ Initializing Device Player...');
            
            try {
                // Initialize IndexedDB
                await initDB();
                console.log('‚úÖ IndexedDB initialized');
                
                // Get registration data
                const storedData = localStorage.getItem('devicePlaylistRegistration');
                if (!storedData) {
                    showError('No device registration found. Redirecting to home...');
                    setTimeout(() => goHome(), 3000);
                    return;
                }
                
                registrationData = JSON.parse(storedData);
                const playlist = registrationData.data?.playlist || registrationData.playlist;
                
                if (!playlist || !playlist.items || playlist.items.length === 0) {
                    showError('Playlist is empty. Please add videos to your playlist.');
                    return;
                }
                
                // Sort timeline items by order
                timelineItems = [...playlist.items].sort((a, b) => a.order - b.order);
                console.log(`üìã Timeline loaded: ${timelineItems.length} videos`);
                
                // Update info overlay
                const deviceUID = localStorage.getItem('deviceUID') || 'Unknown';
                document.getElementById('infoDeviceUID').textContent = deviceUID;
                document.getElementById('infoPlaylistName').textContent = playlist.name;
                document.getElementById('infoTotalVideos').textContent = timelineItems.length;
                
                // Setup video player
                videoPlayer = document.getElementById('videoPlayer');
                videoPlayer.addEventListener('timeupdate', updateVideoInfo);
                
                // Initialize cache status
                for (const item of timelineItems) {
                    cacheStatus[item.video.id] = { cached: false, caching: false };
                }
                
                // Start background caching
                startBackgroundCaching();
                
                // Start playback immediately
                currentVideoIndex = 0;
                loopCount = 0;
                const playSuccess = await playCurrentVideo();
                
                // Try to enter fullscreen automatically on first load
                if (playSuccess && !hasEnteredFullscreenOnce) {
                    setTimeout(() => {
                        enterFullscreen();
                    }, 1000); // Give browser time to start playback first
                }
                
                // Start update intervals
                updateIntervalId = setInterval(updateInfo, 100);
                
                // Start timeline update checker (every 30 seconds)
                timelineCheckIntervalId = setInterval(checkForTimelineUpdates, 30000);
                
            } catch (error) {
                console.error('‚ùå Initialization error:', error);
                showError(`Initialization failed: ${error.message}`);
            }
        }

        // ==================== TIMELINE UPDATE CHECKER ====================
        async function checkForTimelineUpdates() {
            try {
                lastTimelineCheck = Date.now();
                console.log('üîç Checking for timeline updates...');
                
                const playlist = registrationData.data?.playlist || registrationData.playlist;
                const playlistId = playlist.id;
                
                // Fetch latest timeline from server
                const response = await fetch(`/api/playlists/${playlistId}/timeline`);
                
                if (!response.ok) {
                    console.error('Failed to fetch timeline updates:', response.status);
                    return;
                }
                
                const result = await response.json();
                
                if (!result.success || !result.data || result.data.length === 0) {
                    console.log('No timeline data received');
                    return;
                }
                
                // Sort new timeline items
                const newTimelineItems = [...result.data].sort((a, b) => a.order - b.order);
                
                // Check if timeline has changed
                const hasChanged = detectTimelineChanges(timelineItems, newTimelineItems);
                
                if (hasChanged) {
                    console.log('‚úÖ Timeline has changed! Updating...');
                    await handleTimelineUpdate(newTimelineItems);
                } else {
                    console.log('‚ÑπÔ∏è  Timeline unchanged');
                }
                
            } catch (error) {
                console.error('‚ùå Error checking timeline updates:', error);
            }
        }

        function detectTimelineChanges(oldTimeline, newTimeline) {
            // Check if length changed
            if (oldTimeline.length !== newTimeline.length) {
                console.log(`Timeline length changed: ${oldTimeline.length} ‚Üí ${newTimeline.length}`);
                return true;
            }
            
            // Check each item for changes
            for (let i = 0; i < oldTimeline.length; i++) {
                const oldItem = oldTimeline[i];
                const newItem = newTimeline[i];
                
                // Check if video ID changed
                if (oldItem.video.id !== newItem.video.id) {
                    console.log(`Video at position ${i} changed: ${oldItem.video.id} ‚Üí ${newItem.video.id}`);
                    return true;
                }
                
                // Check if duration changed
                if (oldItem.duration !== newItem.duration) {
                    console.log(`Duration at position ${i} changed: ${oldItem.duration}s ‚Üí ${newItem.duration}s`);
                    return true;
                }
                
                // Check if order changed
                if (oldItem.order !== newItem.order) {
                    console.log(`Order at position ${i} changed: ${oldItem.order} ‚Üí ${newItem.order}`);
                    return true;
                }
            }
            
            return false;
        }

        async function handleTimelineUpdate(newTimelineItems) {
            console.log('üîÑ Applying timeline updates...');
            
            // Update global timeline
            timelineItems = newTimelineItems;
            
            // Update info overlay
            document.getElementById('infoTotalVideos').textContent = timelineItems.length;
            
            // Check for new videos that need caching
            const newVideosToCache = [];
            
            for (const item of timelineItems) {
                const videoId = item.video.id;
                
                // If this video is not in cache status, it's new
                if (!cacheStatus[videoId]) {
                    cacheStatus[videoId] = { cached: false, caching: false };
                    newVideosToCache.push(item);
                }
            }
            
            // Cache new videos in background
            if (newVideosToCache.length > 0) {
                console.log(`üì• Found ${newVideosToCache.length} new video(s) to cache`);
                cacheNewVideos(newVideosToCache);
            }
            
            // Update registration data
            if (registrationData.data?.playlist) {
                registrationData.data.playlist.items = timelineItems;
            } else if (registrationData.playlist) {
                registrationData.playlist.items = timelineItems;
            }
            localStorage.setItem('devicePlaylistRegistration', JSON.stringify(registrationData));
            
            console.log('‚úÖ Timeline updated successfully');
        }

        async function cacheNewVideos(newVideos) {
            const totalVideos = timelineItems.length;
            const alreadyCached = Object.values(cacheStatus).filter(s => s.cached).length;
            
            // Show cache indicator
            updateCacheIndicator(alreadyCached, totalVideos);
            
            for (const item of newVideos) {
                try {
                    cacheStatus[item.video.id].caching = true;
                    await cacheVideo(item);
                    cacheStatus[item.video.id].cached = true;
                    
                    const newCachedCount = Object.values(cacheStatus).filter(s => s.cached).length;
                    updateCacheIndicator(newCachedCount, totalVideos);
                } catch (error) {
                    console.error(`‚ùå Failed to cache new video ${item.video.fileName}:`, error);
                    cacheStatus[item.video.id].caching = false;
                }
            }
            
            const finalCachedCount = Object.values(cacheStatus).filter(s => s.cached).length;
            if (finalCachedCount === totalVideos) {
                setTimeout(() => hideCacheIndicator(), 3000);
            }
        }

        // ==================== PLAYBACK CONTROL ====================
        async function playCurrentVideo() {
            if (currentVideoIndex >= timelineItems.length) {
                return false;
            }
            
            const item = timelineItems[currentVideoIndex];
            const videoId = item.video.id;
            const videoName = item.video.fileName;
            
            console.log(`‚ñ∂Ô∏è  Playing [${currentVideoIndex + 1}/${timelineItems.length}]: ${videoName}`);
            
            // Update info overlay
            document.getElementById('infoCurrentVideo').textContent = currentVideoIndex + 1;
            document.getElementById('infoLoopCount').textContent = loopCount;
            document.getElementById('infoItemDuration').textContent = item.duration;
            
            // Set item duration and start time
            itemDuration = item.duration;
            itemStartTime = Date.now();
            
            try {
                // Check if video is cached
                const cachedVideo = await getVideoFromCache(videoId);
                let videoURL;
                
                if (cachedVideo) {
                    console.log(`‚úÖ Playing from cache: ${videoName}`);
                    videoURL = URL.createObjectURL(cachedVideo.blob);
                } else {
                    console.log(`üåê Streaming: ${videoName}`);
                    videoURL = getVideoURL(item.video.filePath);
                }
                
                // Set video source
                videoPlayer.src = videoURL;
                videoPlayer.loop = true; // Loop the video
                videoPlayer.muted = false; // Ensure unmuted
                videoPlayer.volume = 1.0; // Full volume
                videoPlayer.load();
                
                // Play video
                try {
                    await videoPlayer.play();
                    hideClickToPlay();
                    
                    // Start checking item duration
                    startItemDurationCheck();
                    return true; // Success
                } catch (playError) {
                    console.log('‚ö†Ô∏è Autoplay blocked, showing click to play overlay:', playError);
                    showClickToPlay();
                    return false; // Blocked
                }
                
            } catch (error) {
                console.error(`‚ùå Playback error for ${videoName}:`, error);
                // Skip to next video on error
                advanceToNextVideo();
                return false;
            }
        }
        
        function showClickToPlay() {
            document.getElementById('clickToPlayOverlay').classList.add('show');
        }
        
        function hideClickToPlay() {
            document.getElementById('clickToPlayOverlay').classList.remove('show');
        }
        
        async function handleClickToPlay() {
            hideClickToPlay();
            try {
                await videoPlayer.play();
                startItemDurationCheck();
                
                // Try to enter fullscreen after user interaction
                setTimeout(() => {
                    enterFullscreen();
                }, 100);
            } catch (error) {
                console.error('Failed to play after click:', error);
                showError('Failed to start playback. Please check your browser settings.');
            }
        }

        function startItemDurationCheck() {
            // Clear existing interval
            if (checkIntervalId) {
                clearInterval(checkIntervalId);
            }
            
            // Check every 100ms if item duration has elapsed
            checkIntervalId = setInterval(() => {
                const elapsed = (Date.now() - itemStartTime) / 1000;
                
                if (elapsed >= itemDuration) {
                    console.log(`‚è±Ô∏è  Item duration (${itemDuration}s) reached, advancing to next video`);
                    clearInterval(checkIntervalId);
                    advanceToNextVideo();
                }
            }, 100);
        }

        function advanceToNextVideo() {
            // Clean up
            if (checkIntervalId) {
                clearInterval(checkIntervalId);
            }
            
            // Revoke old object URL to free memory
            if (videoPlayer.src && videoPlayer.src.startsWith('blob:')) {
                URL.revokeObjectURL(videoPlayer.src);
            }
            
            // Move to next video
            currentVideoIndex++;
            
            // Check if we've reached the end of the timeline
            if (currentVideoIndex >= timelineItems.length) {
                console.log('üîÑ Timeline complete, looping...');
                currentVideoIndex = 0;
                loopCount++;
            }
            
            // Play next video
            playCurrentVideo();
        }

        function updateVideoInfo() {
            if (!videoPlayer) return;
            
            const current = formatTime(videoPlayer.currentTime);
            const duration = formatTime(videoPlayer.duration);
            const elapsed = Math.floor((Date.now() - itemStartTime) / 1000);
            
            document.getElementById('infoVideoTime').textContent = current;
            document.getElementById('infoVideoDuration').textContent = duration;
            document.getElementById('infoItemElapsed').textContent = elapsed;
        }

        function updateInfo() {
            updateVideoInfo();
            
            // Update countdown to next timeline check
            const timeSinceLastCheck = Math.floor((Date.now() - lastTimelineCheck) / 1000);
            const timeUntilNextCheck = Math.max(0, 30 - timeSinceLastCheck);
            document.getElementById('infoNextUpdate').textContent = timeUntilNextCheck;
        }

        // ==================== BACKGROUND CACHING ====================
        async function startBackgroundCaching() {
            console.log('üì¶ Starting background caching...');
            
            let totalVideos = timelineItems.length;
            let cachedCount = 0;
            
            // Check what's already cached
            for (const item of timelineItems) {
                const cached = await getVideoFromCache(item.video.id);
                if (cached) {
                    cacheStatus[item.video.id].cached = true;
                    cachedCount++;
                }
            }
            
            updateCacheIndicator(cachedCount, totalVideos);
            
            if (cachedCount === totalVideos) {
                console.log('‚úÖ All videos already cached');
                hideCacheIndicator();
                return;
            }
            
            // Cache videos in background
            for (const item of timelineItems) {
                if (cacheStatus[item.video.id].cached) {
                    continue;
                }
                
                try {
                    cacheStatus[item.video.id].caching = true;
                    await cacheVideo(item);
                    cacheStatus[item.video.id].cached = true;
                    cachedCount++;
                    updateCacheIndicator(cachedCount, totalVideos);
                } catch (error) {
                    console.error(`‚ùå Failed to cache ${item.video.fileName}:`, error);
                    cacheStatus[item.video.id].caching = false;
                }
            }
            
            console.log('‚úÖ Background caching complete');
            setTimeout(() => hideCacheIndicator(), 3000);
        }

        async function cacheVideo(item) {
            const videoId = item.video.id;
            const videoPath = item.video.filePath;
            const videoName = item.video.fileName;
            
            console.log(`üì• Caching in background: ${videoName}`);
            
            const videoURL = getVideoURL(videoPath);
            const response = await fetch(videoURL);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            
            const blob = await response.blob();
            await saveVideoToCache(videoId, blob);
            
            console.log(`‚úÖ Cached: ${videoName} (${(blob.size / 1024 / 1024).toFixed(2)} MB)`);
        }

        function getVideoURL(videoPath) {
            if (!videoPath) {
                throw new Error('Video file path is missing');
            }
            
            if (videoPath.startsWith('videos/')) {
                return `/${videoPath}`;
            } else if (videoPath.startsWith('http') || videoPath.startsWith('/')) {
                return videoPath;
            } else {
                return `/videos/${videoPath}`;
            }
        }

        function updateCacheIndicator(cached, total) {
            const percent = total > 0 ? Math.round((cached / total) * 100) : 0;
            document.getElementById('cacheText').textContent = `Caching videos... ${cached}/${total} (${percent}%)`;
            document.getElementById('cacheProgressBar').style.width = `${percent}%`;
            document.getElementById('infoCacheStatus').textContent = `${cached}/${total} cached`;
            
            if (cached < total) {
                document.getElementById('cacheIndicator').classList.add('show');
            }
        }

        function hideCacheIndicator() {
            document.getElementById('cacheIndicator').classList.remove('show');
        }

        // ==================== KEYBOARD CONTROLS ====================
        document.addEventListener('keydown', (e) => {
            switch (e.key.toLowerCase()) {
                case 'h':
                    goHome();
                    break;
                case 'f':
                    // Allow user to toggle fullscreen manually with 'f' key
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    } else {
                        enterFullscreen();
                    }
                    break;
            }
        });

        // ==================== FULLSCREEN HANDLING ====================
        function enterFullscreen() {
            if (videoPlayer && !document.fullscreenElement) {
                hasEnteredFullscreenOnce = true;
                videoPlayer.requestFullscreen().catch(err => {
                    console.log('‚ö†Ô∏è Fullscreen request denied:', err);
                    console.log('You may need to interact with the page first or enable fullscreen in browser settings');
                });
            }
        }

        // Listen for fullscreen changes
        document.addEventListener('fullscreenchange', () => {
            if (document.fullscreenElement) {
                console.log('üì∫ Entered fullscreen mode');
            } else {
                console.log('üñ•Ô∏è  Exited fullscreen mode');
            }
        });

        // ==================== UTILITY FUNCTIONS ====================
        function formatTime(seconds) {
            if (isNaN(seconds) || seconds < 0) return '00:00';
            const s = Math.floor(seconds % 60);
            const m = Math.floor((seconds / 60) % 60);
            const h = Math.floor(seconds / 3600);
            if (h > 0) return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        function goHome() {
            if (confirm('Clear registration and go back to home?')) {
                if (checkIntervalId) clearInterval(checkIntervalId);
                if (updateIntervalId) clearInterval(updateIntervalId);
                if (timelineCheckIntervalId) clearInterval(timelineCheckIntervalId);
                
                clearVideoCache().then(() => {
                    localStorage.removeItem('devicePlaylistRegistration');
                    localStorage.removeItem('deviceUID');
                    window.location.href = '/';
                }).catch(err => {
                    console.error('Error clearing cache:', err);
                    localStorage.removeItem('devicePlaylistRegistration');
                    localStorage.removeItem('deviceUID');
                    window.location.href = '/';
                });
            }
        }

        function showError(message) {
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('errorOverlay').classList.add('show');
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (checkIntervalId) clearInterval(checkIntervalId);
            if (updateIntervalId) clearInterval(updateIntervalId);
            if (timelineCheckIntervalId) clearInterval(timelineCheckIntervalId);
            if (videoPlayer && videoPlayer.src && videoPlayer.src.startsWith('blob:')) {
                URL.revokeObjectURL(videoPlayer.src);
            }
        });
    </script>
</body>
</html>
